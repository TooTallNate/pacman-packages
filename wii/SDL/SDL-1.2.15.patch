diff --git a/configure.in b/configure.in
index 08c8e1e97..a7dfa47b0 100644
--- a/configure.in
+++ b/configure.in
@@ -925,6 +925,86 @@ AC_HELP_STRING([--enable-ipod], [configure SDL to work with iPodLinux [[default=
     fi
 }
 
+CheckNintendoWii()
+{
+    AC_ARG_ENABLE(nintendo-wii,
+AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii [[default=no]]]),
+        , enable_nintendo_wii=no)
+    if test x$enable_nintendo_wii = xyes; then
+        ARCH=nintendo-wii
+        WII_CFLAGS="-mrvl -mcpu=750 -meabi -mhard-float \
+                     -Wall -O2 \
+                     -I${DEVKITPRO}/libogc/include -DGEKKO \
+                     -I${DEVKITPRO}/portlibs/wii/include \
+                     -I${DEVKITPRO}/portlibs/ppc/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $WII_CFLAGS"
+        CFLAGS="$CFLAGS $WII_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $WII_CFLAGS"
+        SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
+                  -L${DEVKITPRO}/portlibs/wii/lib \
+                  -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/wii -laesnd -lwiiuse -lbte -lwiikeyboard -lfat -logc -lm"
+        AC_DEFINE(SDL_TIMER_OGC)
+        SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
+        have_timers=yes
+        AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
+        have_audio=yes
+        AC_DEFINE(SDL_JOYSTICK_WII)
+        SOURCES="$SOURCES $srcdir/src/joystick/wii/*.c"
+        have_joystick=yes
+        AC_DEFINE(SDL_THREAD_OGC)
+        SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
+        have_threads=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/video/wii/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/ogc/*.c"
+        SDLMAIN_SOURCES="$srcdir/src/main/wii/*.c"
+        SDLMAIN_LDFLAGS="-static"
+        have_video=yes
+    fi
+}
+
+CheckNintendoGamecube()
+{
+    AC_ARG_ENABLE(nintendo-gamecube,
+AC_HELP_STRING([--enable-nintendo-gamecube], [configure SDL to work with Nintendo Gamecube [[default=no]]]),
+        , enable_nintendo_wii=no)
+    if test x$enable_nintendo_gamecube = xyes; then
+        ARCH=nintendo-gamecube
+        GAMECUBE_CFLAGS="-mogc -mcpu=750 -meabi -mhard-float \
+                     -Wall -O2 \
+                     -I${DEVKITPRO}/libogc/include -DGEKKO \
+                     -I${DEVKITPRO}/portlibs/gamecube/include \
+                     -I${DEVKITPRO}/portlibs/ppc/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $GAMECUBE_CFLAGS"
+        CFLAGS="$CFLAGS $GAMECUBE_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $GAMECUBE_CFLAGS"
+        SDL_LIBS="-mogc -mcpu=750 -meabi -mhard-float \
+                  -L${DEVKITPRO}/portlibs/gamecube/lib \
+                  -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/cube -laesnd -lfat -logc -lm"
+        AC_DEFINE(SDL_TIMER_OGC)
+        SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
+        have_timers=yes
+        AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
+        have_audio=yes
+        AC_DEFINE(SDL_JOYSTICK_GAMECUBE)
+        SOURCES="$SOURCES $srcdir/src/joystick/gamecube/*.c"
+        have_joystick=yes
+        AC_DEFINE(SDL_THREAD_OGC)
+        SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
+        have_threads=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/video/gamecube/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/ogc/*.c"
+        SDLMAIN_SOURCES="$srcdir/src/main/gamecube/*.c"
+        SDLMAIN_LDFLAGS="-static"
+        have_video=yes
+    fi
+}
+
 dnl Find the nanox include and library directories
 CheckNANOX()
 {
@@ -2314,6 +2394,10 @@ AC_HELP_STRING([--enable-rpath], [use an rpath when linking SDL [[default=yes]]]
 
 dnl Set up the configuration based on the host platform!
 case "$host" in
+    powerpc-*-eabi)
+       CheckNintendoWii
+       CheckNintendoGamecube
+       ;;
     arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
         ARCH=linux
         CheckDummyVideo
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 8bb1773c0..212f2cf67 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -185,6 +185,7 @@
 #undef SDL_AUDIO_DRIVER_SNDMGR
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WAVEOUT
+#undef SDL_AUDIO_DRIVER_OGC
 
 /* Enable various cdrom drivers */
 #undef SDL_CDROM_AIX
@@ -215,6 +216,8 @@
 #undef SDL_JOYSTICK_MINT
 #undef SDL_JOYSTICK_OS2
 #undef SDL_JOYSTICK_RISCOS
+#undef SDL_JOYSTICK_WII
+#undef SDL_JOYSTICK_GAMECUBE
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
@@ -238,6 +241,7 @@
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
 #undef SDL_THREAD_SPROC
+#undef SDL_THREAD_OGC
 #undef SDL_THREAD_WIN32
 
 /* Enable various timer systems */
@@ -249,6 +253,7 @@
 #undef SDL_TIMER_OS2
 #undef SDL_TIMER_RISCOS
 #undef SDL_TIMER_UNIX
+#undef SDL_TIMER_OGC
 #undef SDL_TIMER_WIN32
 #undef SDL_TIMER_WINCE
 
@@ -279,6 +284,7 @@
 #undef SDL_VIDEO_DRIVER_SVGALIB
 #undef SDL_VIDEO_DRIVER_TOOLBOX
 #undef SDL_VIDEO_DRIVER_VGL
+#undef SDL_VIDEO_DRIVER_OGC
 #undef SDL_VIDEO_DRIVER_WINDIB
 #undef SDL_VIDEO_DRIVER_WSCONS
 #undef SDL_VIDEO_DRIVER_X11
diff --git a/include/SDL_main.h b/include/SDL_main.h
index ab50ef1e2..9824c5063 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -32,7 +32,8 @@
 #if defined(__WIN32__) || \
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
-    defined(__SYMBIAN32__) || defined(QWS)
+    defined(__SYMBIAN32__) || defined(QWS) || \
+    defined(__wii__) || defined(__gamecube__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index beb26e0b4..fbbeb459f 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -112,6 +112,9 @@ static AudioBootStrap *bootstrap[] = {
 #endif
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 	&EPOCAudio_bootstrap,
+#endif
+#if SDL_AUDIO_DRIVER_OGC
+	&OGCAUD_bootstrap,
 #endif
 	NULL
 };
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 74ac21df0..e701a570a 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -179,6 +179,9 @@ extern AudioBootStrap DART_bootstrap;
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 extern AudioBootStrap EPOCAudio_bootstrap; 
 #endif
+#if SDL_AUDIO_DRIVER_OGC
+extern AudioBootStrap OGCAUD_bootstrap;
+#endif
 
 /* This is the current audio device */
 extern SDL_AudioDevice *current_audio;
diff --git a/src/audio/ogc/SDL_ogcAudio.c b/src/audio/ogc/SDL_ogcAudio.c
new file mode 100644
index 000000000..70b7f9b6d
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcAudio.c
@@ -0,0 +1,293 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken at libsdl.or
+*/
+#include "SDL_config.h"
+
+// Public includes.
+#include "SDL_timer.h"
+
+// Audio internal includes.
+#include "SDL_audio.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_sysaudio.h"
+#include "../SDL_audio_c.h"
+
+// Wii audio internal includes.
+#include "SDL_ogcAudio.h"
+
+#include <stdio.h>
+
+// for memalign
+#include <malloc.h>
+
+static const char OGCAUD_DRIVER_NAME[] = "ogc";
+
+#define DMA_BUFFER_SIZE (SAMPLES_PER_DMA_BUFFER*2*sizeof(short))
+
+static lwp_t athread;
+static ogcAudio *current = NULL;
+
+/****************************************************************************
+ * Audio Threading
+ ***************************************************************************/
+static void *
+AudioThread (ogcAudio *private)
+{
+	u32 buffer_size;
+	Uint8 whichab = 1;
+
+	while (1)
+	{
+		LWP_SuspendThread(athread);
+		if (private->stopaudio)
+			break;
+
+		DCZeroRange(private->dma_buffers[whichab], DMA_BUFFER_SIZE);
+		buffer_size = DMA_BUFFER_SIZE;
+
+		// Is the device ready?
+		if (current_audio && !current_audio->paused)
+		{
+			SDL_LockMutex(current_audio->mixer_lock);
+
+			if (current_audio->convert.needed)
+			{
+				// Get the client to produce audio
+				current_audio->spec.callback(
+						current_audio->spec.userdata,
+						current_audio->convert.buf,
+						current_audio->convert.len);
+
+				// Convert the audio
+				SDL_ConvertAudio(&current_audio->convert);
+
+				// Copy from SDL buffer to DMA buffer
+				memcpy(private->dma_buffers[whichab], current_audio->convert.buf, current_audio->convert.len_cvt);
+				buffer_size = current_audio->convert.len_cvt;
+			} else {
+				current_audio->spec.callback(
+					current_audio->spec.userdata,
+					(Uint8 *)(private->dma_buffers[whichab]),
+					DMA_BUFFER_SIZE);
+				buffer_size = DMA_BUFFER_SIZE;
+			}
+
+			SDL_UnlockMutex(current_audio->mixer_lock);
+		}
+		else if (current_audio && (current_audio->spec.format&0x8000)==0) // hack
+		{
+			int i;
+			// if it's an unsigned format use 0x8000 for silence (16-bit)
+			short fill = 0x8000;
+
+			// 0x80 for 8-bit formats
+			if (current_audio->spec.format&0x08)
+				fill |= 0x80;
+
+			for (i=0; i < SAMPLES_PER_DMA_BUFFER*2; i++)
+				private->dma_buffers[whichab][i] = fill;
+		}
+
+		AESND_SetVoiceBuffer(private->voice, private->dma_buffers[whichab], buffer_size);
+		whichab ^= 1;
+	}
+	return NULL;
+}
+
+/****************************************************************************
+ * DMACallback
+ * signal audio thread that more samples are required
+ ***************************************************************************/
+static void
+DMACallback(AESNDPB *pb, u32 state)
+{
+	if (state == VOICE_STATE_STREAM)
+		LWP_ResumeThread(athread);
+}
+
+void OGC_AudioStop(ogcAudio *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
+	}
+
+	if (private->voice) {
+		AESND_SetVoiceStop(private->voice, 1);
+		AESND_FreeVoice(private->voice);
+		private->voice = NULL;
+	}
+
+	private->stopaudio = true;
+	if (athread != LWP_THREAD_NULL) {
+		LWP_ResumeThread(athread);
+		LWP_JoinThread(athread, NULL);
+		athread = LWP_THREAD_NULL;
+	}
+
+	AESND_Pause(1);
+	// this function is broken
+	//AESND_Reset();
+}
+
+int OGC_AudioStart(ogcAudio *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return -1;
+		private = current;
+	}
+
+	memset(private->dma_buffers, 0, sizeof(private->dma_buffers));
+	private->stopaudio = false;
+	private->voice = AESND_AllocateVoice(DMACallback);
+	if (private->voice==NULL)
+		return -1;
+
+	if (LWP_CreateThread(&athread, (void*(*)(void*))AudioThread, private, private->astack, AUDIOSTACK, 80) < 0) {
+		AESND_FreeVoice(private->voice);
+		private->voice = NULL;
+		return -1;
+	}
+
+	// start audio
+	// this is retarded. Why isn't there one function to do all this shit?
+	AESND_SetVoiceFormat(private->voice, private->format);
+	AESND_SetVoiceFrequency(private->voice, private->freq);
+	AESND_SetVoiceBuffer(private->voice, private->dma_buffers[0], DMA_BUFFER_SIZE);
+	AESND_SetVoiceStream(private->voice, true);
+	AESND_SetVoiceStop(private->voice, 0);
+	AESND_Pause(0);
+
+	current = private;
+	return 1;
+}
+
+static int OGCAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+{
+	u32 format;
+	ogcAudio *private = (ogcAudio*)(this->hidden);
+
+	if (spec->freq <= 0 || spec->freq > 144000)
+		spec->freq = DSP_DEFAULT_FREQ;
+
+	// default sample size = 1 byte (1 channel @ 8 bits)
+	spec->samples = DMA_BUFFER_SIZE;
+
+	// no support for little endian or 16 bit unsigned
+	switch (spec->format) {
+		case AUDIO_U8:
+			format = VOICE_MONO8_UNSIGNED;
+			break;
+		case AUDIO_S8:
+			format = VOICE_MONO8;
+			break;
+		// anything else needs conversion to signed 16 big-endian
+		default:
+		case AUDIO_U16LSB:
+		case AUDIO_U16MSB:
+		case AUDIO_S16LSB:
+			spec->format = AUDIO_S16MSB;
+			// fallthrough
+		case AUDIO_S16MSB:
+			format = VOICE_MONO16;
+			// samples are 16 bits
+			spec->samples >>= 1;
+	}
+
+	// support 2 channels max
+	if (spec->channels > 2)
+		spec->channels = 2;
+
+	if (spec->channels == 2) {
+		++format;
+		// 2 values for each sample
+		spec->samples >>= 1;
+	}
+
+	spec->padding	= 0;
+	SDL_CalculateAudioSpec(spec);
+
+	private->format = format;
+	// AESND will convert frequency as required
+	private->freq = spec->freq;
+
+	return OGC_AudioStart(private);
+}
+
+static void OGCAUD_CloseAudio(_THIS)
+{
+	OGC_AudioStop((ogcAudio*)(this->hidden));
+	current = NULL;
+}
+
+static void OGCAUD_DeleteDevice(_THIS)
+{
+	OGC_AudioStop((ogcAudio*)(this->hidden));
+
+	free(this->hidden);
+	SDL_free(this);
+}
+
+static SDL_AudioDevice *OGCAUD_CreateDevice(int devindex)
+{
+	SDL_AudioDevice *this;
+
+	athread = LWP_THREAD_NULL;
+
+	/* Initialize all variables that we clean on shutdown */
+	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
+	if ( this ) {
+		SDL_memset(this, 0, (sizeof *this));
+		this->hidden = (ogcAudio*)memalign(32, sizeof(ogcAudio));
+	}
+	if ( (this == NULL) || (this->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		SDL_free(this);
+		return NULL;
+	}
+	SDL_memset(this->hidden, 0, sizeof(ogcAudio));
+
+	// Initialise the ogc side of the audio system
+	AESND_Init();
+	AESND_Pause(1);
+
+	/* Set the function pointers */
+	this->OpenAudio = OGCAUD_OpenAudio;
+	//this->WaitAudio = WIIAUD_WaitAudio;
+	//this->PlayAudio = WIIAUD_PlayAudio;
+	//this->GetAudioBuf = WIIAUD_GetAudioBuf;
+	this->CloseAudio = OGCAUD_CloseAudio;
+	this->free = OGCAUD_DeleteDevice;
+
+	return this;
+}
+
+static int OGCAUD_Available(void)
+{
+	return 1;
+}
+
+AudioBootStrap OGCAUD_bootstrap = {
+	OGCAUD_DRIVER_NAME, "SDL ogc audio driver",
+	OGCAUD_Available, OGCAUD_CreateDevice
+};
diff --git a/src/audio/ogc/SDL_ogcAudio.h b/src/audio/ogc/SDL_ogcAudio.h
new file mode 100644
index 000000000..57a44f34b
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcAudio.h
@@ -0,0 +1,49 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_ogcAudio_h
+#define _SDL_ogcAudio_h
+
+#include <ogcsys.h>
+#include <aesndlib.h>
+
+#include "../SDL_sysaudio.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_AudioDevice *this
+
+#define AUDIOSTACK 8192
+#define SAMPLES_PER_DMA_BUFFER (DSP_STREAMBUFFER_SIZE)
+
+typedef struct SDL_PrivateAudioData {
+    // these go first so they will be aligned
+    Uint8 astack[AUDIOSTACK];
+    short dma_buffers[2][SAMPLES_PER_DMA_BUFFER*2];
+
+    AESNDPB* voice;
+    u32 format;
+    u32 freq;
+    volatile bool stopaudio;
+} ogcAudio;
+
+#endif /* _SDL_dummyaudio_h */
diff --git a/src/joystick/gamecube/SDL_sysjoystick.c b/src/joystick/gamecube/SDL_sysjoystick.c
new file mode 100644
index 000000000..9709c5e47
--- /dev/null
+++ b/src/joystick/gamecube/SDL_sysjoystick.c
@@ -0,0 +1,240 @@
+/*
+ SDL - Simple DirectMedia Layer
+ Copyright (C) 1997-2006 Sam Lantinga
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Sam Lantinga
+ slouken@libsdl.org
+ */
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_GAMECUBE
+
+#include "SDL_events.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include <gccore.h>
+#include <unistd.h>
+#include <math.h>
+
+#define MAX_GC_JOYSTICKS	4
+#define MAX_JOYSTICKS		MAX_GC_JOYSTICKS
+
+#define MAX_GC_AXES			6
+#define MAX_GC_BUTTONS		8
+#define	MAX_GC_HATS			1
+
+#define	JOYNAMELEN			10
+
+#define AXIS_MIN	-32767  /* minimum value for axis coordinate */
+#define AXIS_MAX	32767   /* maximum value for axis coordinate */
+
+typedef struct joystick_paddata_t
+{
+	u16 prev_buttons;
+	s8 stickX;
+	s8 stickY;
+	s8 substickX;
+	s8 substickY;
+	u8 triggerL;
+	u8 triggerR;
+}joystick_paddata;
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata_t
+{
+	int index;
+	int type;
+	joystick_paddata gamecube;
+} joystick_hwdata;
+
+static const u16 sdl_buttons_gc[] =
+{
+	PAD_BUTTON_A,
+	PAD_BUTTON_B,
+	0 /* 1 */,
+	0 /* 2 */,
+	0 /* - */,
+	PAD_TRIGGER_Z,
+	PAD_BUTTON_START,
+	0 /* Z */,
+	0 /* C */,
+	PAD_BUTTON_X,
+	PAD_BUTTON_Y,
+	PAD_TRIGGER_L,
+	PAD_TRIGGER_R
+};
+
+static const int __numgcjoysticks = 4;
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+	return 4;
+}
+
+static char joy_name[] = "Gamecube 0";
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	if(index>=0) {
+
+		if(index < 4 && index < __numgcjoysticks)
+			sprintf(joy_name, "Gamecube %d", index);
+	}
+	return (const char *)joy_name;
+}
+
+/* Function to open a joystick for use.
+ The joystick to open is specified by the index field of the joystick.
+ This should fill the nbuttons and naxes fields of the joystick structure.
+ It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	/* allocate memory for system specific hardware data */
+	joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+	if (joystick->hwdata == NULL)
+	{
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+
+	if(joystick->index < __numgcjoysticks)
+	{
+		((joystick_hwdata*)(joystick->hwdata))->index = joystick->index;
+		((joystick_hwdata*)(joystick->hwdata))->type = 1;
+		joystick->nbuttons = MAX_GC_BUTTONS;
+		joystick->naxes = MAX_GC_AXES;
+		joystick->nhats = MAX_GC_HATS;
+	}
+	return(0);
+}
+
+static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
+{
+	u16 buttons, prev_buttons, changed;
+	int i;
+	int axis;
+	joystick_hwdata *prev_state;
+	int index = joystick->index - 4;
+
+	buttons = PAD_ButtonsHeld(index);
+	prev_state = (joystick_hwdata *)joystick->hwdata;
+	prev_buttons = prev_state->gamecube.prev_buttons;
+	changed = buttons ^ prev_buttons;
+
+	if(changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP))
+	{
+		int hat = SDL_HAT_CENTERED;
+		if(buttons & PAD_BUTTON_UP) hat |= SDL_HAT_UP;
+		if(buttons & PAD_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
+		if(buttons & PAD_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
+		if(buttons & PAD_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++)
+	{
+		if (changed & sdl_buttons_gc[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+	prev_state->gamecube.prev_buttons = buttons;
+	axis = PAD_StickX(index);
+	if(prev_state->gamecube.stickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+		prev_state->gamecube.stickX = axis;
+	}
+
+	axis = PAD_StickY(index);
+	if(prev_state->gamecube.stickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+		prev_state->gamecube.stickY = axis;
+	}
+
+	axis = PAD_SubStickX(index);
+	if(prev_state->gamecube.substickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+		prev_state->gamecube.substickX = axis;
+	}
+
+	axis = PAD_SubStickY(index);
+	if(prev_state->gamecube.substickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+		prev_state->gamecube.substickY = axis;
+	}
+
+	axis = PAD_TriggerL(index);
+	if(prev_state->gamecube.triggerL != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 4, axis << 8);
+		prev_state->gamecube.triggerL = axis;
+	}
+
+	axis = PAD_TriggerR(index);
+	if(prev_state->gamecube.triggerR != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 5, axis << 8);
+		prev_state->gamecube.triggerR = axis;
+	}
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata)
+		return;
+
+	PAD_ScanPads();
+
+	_HandleGCJoystickUpdate(joystick);
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata) // joystick already closed
+		return;
+
+	SDL_free(joystick->hwdata);
+	joystick->hwdata = NULL;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+
+}
+
+#endif /* SDL_JOYSTICK_DC */
diff --git a/src/joystick/wii/SDL_sysjoystick.c b/src/joystick/wii/SDL_sysjoystick.c
new file mode 100644
index 000000000..88aa28ddb
--- /dev/null
+++ b/src/joystick/wii/SDL_sysjoystick.c
@@ -0,0 +1,582 @@
+/*
+ SDL - Simple DirectMedia Layer
+ Copyright (C) 1997-2006 Sam Lantinga
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Sam Lantinga
+ slouken@libsdl.org
+ */
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_WII
+
+#include "SDL_events.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include <gccore.h>
+#include <unistd.h>
+#include <wiiuse/wpad.h>
+#include <math.h>
+
+#define PI 					3.14159265f
+
+#define MAX_GC_JOYSTICKS	4
+#define MAX_WII_JOYSTICKS	4
+#define MAX_JOYSTICKS		(MAX_GC_JOYSTICKS + MAX_WII_JOYSTICKS)
+
+#define MAX_GC_AXES			6
+#define MAX_GC_BUTTONS		8
+#define	MAX_GC_HATS			1
+
+#define MAX_WII_AXES		9
+#define MAX_WII_BUTTONS		15
+#define	MAX_WII_HATS		1
+
+#define	JOYNAMELEN			10
+
+#define AXIS_MIN	-32767  /* minimum value for axis coordinate */
+#define AXIS_MAX	32767   /* maximum value for axis coordinate */
+
+typedef struct joystick_paddata_t
+{
+	u16 prev_buttons;
+	s8 stickX;
+	s8 stickY;
+	s8 substickX;
+	s8 substickY;
+	u8 triggerL;
+	u8 triggerR;
+}joystick_paddata;
+
+typedef struct joystick_wpaddata_t
+{
+	u32 prev_buttons;
+	u32 exp;
+	s16 nunchuk_stickX;
+	s16 nunchuk_stickY;
+	s16 classicL_stickX;
+	s16 classicL_stickY;
+	s16 classicR_stickX;
+	s16 classicR_stickY;
+	u8 classic_triggerL;
+	u8 classic_triggerR;
+	u8 classic_calibrated;
+	s8 wiimote_pitch;
+	s8 wiimote_roll;
+	s8 wiimote_yaw;
+	s16 classic_cal[4][3]; // 4x axes, min/center/max
+}joystick_wpaddata;
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata_t
+{
+	int index;
+	int type;
+	union
+	{
+		joystick_paddata gamecube;
+		joystick_wpaddata wiimote;
+	};
+} joystick_hwdata;
+
+static const u32 sdl_buttons_wii[] =
+{
+	WPAD_BUTTON_A|WPAD_CLASSIC_BUTTON_A,
+	WPAD_BUTTON_B|WPAD_CLASSIC_BUTTON_B,
+	WPAD_BUTTON_1,
+	WPAD_BUTTON_2,
+	WPAD_BUTTON_MINUS|WPAD_CLASSIC_BUTTON_MINUS,
+	WPAD_BUTTON_PLUS|WPAD_CLASSIC_BUTTON_PLUS,
+	WPAD_BUTTON_HOME|WPAD_CLASSIC_BUTTON_HOME,
+	WPAD_NUNCHUK_BUTTON_Z, /* 7 */
+	WPAD_NUNCHUK_BUTTON_C, /* 8 */
+	WPAD_CLASSIC_BUTTON_X, /* 9 */
+	WPAD_CLASSIC_BUTTON_Y,
+	WPAD_CLASSIC_BUTTON_FULL_L,
+	WPAD_CLASSIC_BUTTON_FULL_R,
+	WPAD_CLASSIC_BUTTON_ZL,
+	WPAD_CLASSIC_BUTTON_ZR
+};
+
+static const u16 sdl_buttons_gc[] =
+{
+	PAD_BUTTON_A,
+	PAD_BUTTON_B,
+	0 /* 1 */,
+	0 /* 2 */,
+	0 /* - */,
+	PAD_TRIGGER_Z,
+	PAD_BUTTON_START,
+	0 /* Z */,
+	0 /* C */,
+	PAD_BUTTON_X,
+	PAD_BUTTON_Y,
+	PAD_TRIGGER_L,
+	PAD_TRIGGER_R
+};
+
+static const int __jswpad_enabled = 1;
+static const int __jspad_enabled = 1;
+static const int __numwiijoysticks = 4;
+static const int __numgcjoysticks = 4;
+
+/* Helpers to separate nunchuk vs classic buttons which share the
+ * same scan codes. In particular, up on the classic controller is
+ * the same as Z on the nunchuk. The numbers refer to the sdl_buttons_wii
+ * list above. */
+static int wii_button_is_nunchuk(int idx)
+{
+	return idx == 7 || idx == 8;
+}
+
+static int wii_button_is_classic(int idx)
+{
+	return idx >= 9;
+}
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+	return 8;
+}
+
+static char joy_name[] = "Gamecube 0";
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	if(index>=0) {
+
+		if((index < 4) && (__jswpad_enabled) && (index < __numwiijoysticks))
+			sprintf(joy_name, "Wiimote %d", index);
+		else if((index < 8) && (__jspad_enabled) && (index < (__numgcjoysticks + 4)) && (index> 3))
+			sprintf(joy_name, "Gamecube %d", index);
+	}
+	return (const char *)joy_name;
+}
+
+/* Function to open a joystick for use.
+ The joystick to open is specified by the index field of the joystick.
+ This should fill the nbuttons and naxes fields of the joystick structure.
+ It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	/* allocate memory for system specific hardware data */
+	joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+	if (joystick->hwdata == NULL)
+	{
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+	if((joystick->index < 4) && (__jswpad_enabled))
+	{
+		if(joystick->index < __numwiijoysticks)
+		{
+			((joystick_hwdata*)(joystick->hwdata))->index = joystick->index;
+			((joystick_hwdata*)(joystick->hwdata))->type = 0;
+			joystick->nbuttons = MAX_WII_BUTTONS;
+			joystick->naxes = MAX_WII_AXES;
+			joystick->nhats = MAX_WII_HATS;
+		}
+	}
+	else if((joystick->index < 8) && (__jspad_enabled))
+	{
+		if(joystick->index < (__numgcjoysticks + 4))
+		{
+			((joystick_hwdata*)(joystick->hwdata))->index = joystick->index - 4;
+			((joystick_hwdata*)(joystick->hwdata))->type = 1;
+			joystick->nbuttons = MAX_GC_BUTTONS;
+			joystick->naxes = MAX_GC_AXES;
+			joystick->nhats = MAX_GC_HATS;
+		}
+	}
+	return(0);
+}
+
+static s16 WPAD_Orient(WPADData *data, int motion)
+{
+	float out;
+
+	if (motion == 0)
+		out = data->orient.pitch;
+	else if (motion == 1)
+		out = data->orient.roll;
+	else
+		out = data->orient.yaw;
+
+	return (s16)((out / 180.0) * 128.0);
+}
+
+static s16 WPAD_Pitch(WPADData *data)
+{
+	return WPAD_Orient(data, 0);
+}
+
+static s16 WPAD_Roll(WPADData *data)
+{
+	return WPAD_Orient(data, 1);
+}
+
+static s16 WPAD_Yaw(WPADData *data)
+{
+	return WPAD_Orient(data, 2);
+}
+
+static s16 WPAD_Stick(s16 x, s16 min, s16 center, s16 max, int flip)
+{
+	s16 d;
+	int ret;
+
+	x -= center;
+
+	if (x < 0)
+		d = center - min;
+	else
+		d = max - center;
+
+	if (center - min < 5) return 0;
+	if (max - center < 5) return 0;
+
+	if (d)
+		ret = (x << 15) / d;
+	else
+		return 0;
+
+	if (flip)
+		ret = -ret;
+
+	if (ret < AXIS_MIN)
+		ret = AXIS_MIN;
+	else if (ret > AXIS_MAX)
+		ret = AXIS_MAX;
+
+	return ret;
+}
+
+static const u32 _buttons[8] = {
+	// wiimote
+	WPAD_BUTTON_UP,
+	WPAD_BUTTON_DOWN,
+	WPAD_BUTTON_LEFT,
+	WPAD_BUTTON_RIGHT,
+	// classic
+	WPAD_CLASSIC_BUTTON_UP,
+	WPAD_CLASSIC_BUTTON_DOWN,
+	WPAD_CLASSIC_BUTTON_LEFT,
+	WPAD_CLASSIC_BUTTON_RIGHT
+};
+
+static void _HandleWiiJoystickUpdate(SDL_Joystick* joystick)
+{
+	u32 changed;
+	int i, axis;
+	joystick_hwdata *prev_state;
+	WPADData *data;
+	const u32 *buttons;
+
+	if (!WPAD_ReadPending(joystick->index, NULL))
+		return;
+	data = WPAD_Data(joystick->index);
+	changed = data->btns_d | data->btns_u;
+	prev_state = (joystick_hwdata*)joystick->hwdata;
+
+	if(data->exp.type == WPAD_EXP_CLASSIC) // classic controller
+		buttons = _buttons+4;
+	else
+		buttons = _buttons;
+
+	if (changed & (buttons[0]|buttons[1]|buttons[2]|buttons[3]))
+	{
+		int hat = SDL_HAT_CENTERED;
+		u32 pressed = data->btns_d | data->btns_h;
+
+		if (pressed & buttons[0]) hat |= SDL_HAT_UP;
+		if (pressed & buttons[1]) hat |= SDL_HAT_DOWN;
+		if (pressed & buttons[2]) hat |= SDL_HAT_LEFT;
+		if (pressed & buttons[3]) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_wii) / sizeof(sdl_buttons_wii[0])); i++)
+	{
+		if ( (data->exp.type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
+				(data->exp.type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i)) )
+			continue;
+
+		if (changed & sdl_buttons_wii[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(data->btns_d & sdl_buttons_wii[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+
+	if(data->exp.type == WPAD_EXP_CLASSIC)
+	{
+		if (prev_state->wiimote.exp != WPAD_EXP_CLASSIC)
+		{
+			prev_state->wiimote.classic_calibrated = 0;
+			prev_state->wiimote.classic_cal[0][0] = 5;  // left x min
+			prev_state->wiimote.classic_cal[0][2] = 59; // left x max
+			prev_state->wiimote.classic_cal[1][0] = 5; // left y min
+			prev_state->wiimote.classic_cal[1][2] = 59;  // left y max
+			prev_state->wiimote.classic_cal[2][0] = 5;  // right x min
+			prev_state->wiimote.classic_cal[2][2] = 27; // right x max
+			prev_state->wiimote.classic_cal[3][0] = 5; // right y min
+			prev_state->wiimote.classic_cal[3][2] = 27;  // right y max
+
+		}
+
+		// max/min checking
+		// left stick x
+		if (data->exp.classic.ljs.pos.x < prev_state->wiimote.classic_cal[0][0])
+			prev_state->wiimote.classic_cal[0][0] = data->exp.classic.ljs.pos.x;
+		else if (data->exp.classic.ljs.pos.x > prev_state->wiimote.classic_cal[0][2])
+			prev_state->wiimote.classic_cal[0][2] = data->exp.classic.ljs.pos.x;
+		// left stick y
+		if (data->exp.classic.ljs.pos.y < prev_state->wiimote.classic_cal[1][0])
+			prev_state->wiimote.classic_cal[1][0] = data->exp.classic.ljs.pos.y;
+		else if (data->exp.classic.ljs.pos.y > prev_state->wiimote.classic_cal[1][2])
+			prev_state->wiimote.classic_cal[1][2] = data->exp.classic.ljs.pos.y;
+		// right stick x
+		if (data->exp.classic.rjs.pos.x < prev_state->wiimote.classic_cal[2][0])
+			prev_state->wiimote.classic_cal[2][0] = data->exp.classic.rjs.pos.x;
+		else if (data->exp.classic.rjs.pos.x > prev_state->wiimote.classic_cal[2][2])
+			prev_state->wiimote.classic_cal[2][2] = data->exp.classic.rjs.pos.x;
+		// right stick y
+		if (data->exp.classic.rjs.pos.y < prev_state->wiimote.classic_cal[3][0])
+			prev_state->wiimote.classic_cal[3][0] = data->exp.classic.rjs.pos.y;
+		else if (data->exp.classic.rjs.pos.y > prev_state->wiimote.classic_cal[3][2])
+			prev_state->wiimote.classic_cal[3][2] = data->exp.classic.rjs.pos.y;
+
+		// calibrate center positions
+		if (prev_state->wiimote.classic_calibrated < 5)
+		{
+			prev_state->wiimote.classic_cal[0][1] = data->exp.classic.ljs.pos.x;
+			prev_state->wiimote.classic_cal[1][1] = data->exp.classic.ljs.pos.y;
+			prev_state->wiimote.classic_cal[2][1] = data->exp.classic.rjs.pos.x;
+			prev_state->wiimote.classic_cal[3][1] = data->exp.classic.rjs.pos.y;
+			// this is zero if the expansion hasn't finished initializing
+			if (data->exp.classic.ljs.max.x)
+				prev_state->wiimote.classic_calibrated++;
+		}
+
+		axis = WPAD_Stick(data->exp.classic.ljs.pos.x, prev_state->wiimote.classic_cal[0][0],
+			prev_state->wiimote.classic_cal[0][1], prev_state->wiimote.classic_cal[0][2], 0);
+		if(prev_state->wiimote.classicL_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 0, axis);
+			prev_state->wiimote.classicL_stickX = axis;
+		}
+		// y axes are reversed
+		axis = WPAD_Stick(data->exp.classic.ljs.pos.y, prev_state->wiimote.classic_cal[1][0],
+			prev_state->wiimote.classic_cal[1][1], prev_state->wiimote.classic_cal[1][2], 1);
+		if(prev_state->wiimote.classicL_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 1, axis);
+			prev_state->wiimote.classicL_stickY = axis;
+		}
+		axis = WPAD_Stick(data->exp.classic.rjs.pos.x, prev_state->wiimote.classic_cal[2][0],
+			prev_state->wiimote.classic_cal[2][1], prev_state->wiimote.classic_cal[2][2], 0);
+		if(prev_state->wiimote.classicR_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 2, axis);
+			prev_state->wiimote.classicR_stickX = axis;
+		}
+		axis = WPAD_Stick(data->exp.classic.rjs.pos.y, prev_state->wiimote.classic_cal[3][0],
+			prev_state->wiimote.classic_cal[3][1], prev_state->wiimote.classic_cal[3][2], 1);
+		if(prev_state->wiimote.classicR_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 3, axis);
+			prev_state->wiimote.classicR_stickY = axis;
+		}
+		axis = data->exp.classic.r_shoulder;
+		if(prev_state->wiimote.classic_triggerR != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 4, axis<<8);
+			prev_state->wiimote.classic_triggerR = axis;
+		}
+		axis = data->exp.classic.l_shoulder;
+		if(prev_state->wiimote.classic_triggerL != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 5, axis<<8);
+			prev_state->wiimote.classic_triggerL = axis;
+		}
+	}
+	else if(data->exp.type == WPAD_EXP_NUNCHUK)
+	{
+		axis = WPAD_Stick(data->exp.nunchuk.js.pos.x, data->exp.nunchuk.js.min.x,
+			data->exp.nunchuk.js.center.x, data->exp.nunchuk.js.max.x, 0);
+		if(prev_state->wiimote.nunchuk_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 0, axis);
+			prev_state->wiimote.nunchuk_stickX = axis;
+		}
+		axis = WPAD_Stick(data->exp.nunchuk.js.pos.y, data->exp.nunchuk.js.min.y,
+			data->exp.nunchuk.js.center.y, data->exp.nunchuk.js.max.y, 1);
+		if(prev_state->wiimote.nunchuk_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joystick, 1, axis);
+			prev_state->wiimote.nunchuk_stickY = axis;
+		}
+	}
+
+	prev_state->wiimote.exp = data->exp.type;
+
+	axis = WPAD_Pitch(data);
+	if(prev_state->wiimote.wiimote_pitch != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 6, -(axis << 8));
+		prev_state->wiimote.wiimote_pitch = axis;
+	}
+	axis = WPAD_Roll(data);
+	if(prev_state->wiimote.wiimote_roll != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 7, axis << 8);
+		prev_state->wiimote.wiimote_roll = axis;
+	}
+	axis = WPAD_Yaw(data);
+	if(prev_state->wiimote.wiimote_yaw != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 8, axis << 8);
+		prev_state->wiimote.wiimote_yaw = axis;
+	}
+}
+
+static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
+{
+	u16 buttons, prev_buttons, changed;
+	int i;
+	int axis;
+	joystick_hwdata *prev_state;
+	int index = joystick->index - 4;
+
+	buttons = PAD_ButtonsHeld(index);
+	prev_state = (joystick_hwdata *)joystick->hwdata;
+	prev_buttons = prev_state->gamecube.prev_buttons;
+	changed = buttons ^ prev_buttons;
+
+	if(changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP))
+	{
+		int hat = SDL_HAT_CENTERED;
+		if(buttons & PAD_BUTTON_UP) hat |= SDL_HAT_UP;
+		if(buttons & PAD_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
+		if(buttons & PAD_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
+		if(buttons & PAD_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++)
+	{
+		if (changed & sdl_buttons_gc[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+	prev_state->gamecube.prev_buttons = buttons;
+	axis = PAD_StickX(index);
+	if(prev_state->gamecube.stickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+		prev_state->gamecube.stickX = axis;
+	}
+
+	axis = PAD_StickY(index);
+	if(prev_state->gamecube.stickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+		prev_state->gamecube.stickY = axis;
+	}
+
+	axis = PAD_SubStickX(index);
+	if(prev_state->gamecube.substickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+		prev_state->gamecube.substickX = axis;
+	}
+
+	axis = PAD_SubStickY(index);
+	if(prev_state->gamecube.substickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+		prev_state->gamecube.substickY = axis;
+	}
+
+	axis = PAD_TriggerL(index);
+	if(prev_state->gamecube.triggerL != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 4, axis << 8);
+		prev_state->gamecube.triggerL = axis;
+	}
+
+	axis = PAD_TriggerR(index);
+	if(prev_state->gamecube.triggerR != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 5, axis << 8);
+		prev_state->gamecube.triggerR = axis;
+	}
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata)
+		return;
+
+//	WPAD_ScanPads();
+	PAD_ScanPads();
+
+	switch(((joystick_hwdata*)(joystick->hwdata))->type)
+	{
+		case 0:
+		if(__jswpad_enabled)
+		_HandleWiiJoystickUpdate(joystick);
+		break;
+		case 1:
+		if(__jspad_enabled)
+		_HandleGCJoystickUpdate(joystick);
+		//break;
+		default:
+		break;
+	}
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata) // joystick already closed
+		return;
+
+	SDL_free(joystick->hwdata);
+	joystick->hwdata = NULL;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+
+}
+
+#endif /* SDL_JOYSTICK_DC */
diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
new file mode 100644
index 000000000..59288fb44
--- /dev/null
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -0,0 +1,26 @@
+/* Include the SDL main definition header */
+#include "SDL_main.h"
+#undef main
+
+/* Standard includes */
+#include <stdio.h>
+
+/* SDL includes */
+#include "../../video/ogc/SDL_ogc_video.h"
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+//	SYS_SetPowerCallback(ShutdownCB);
+//	SYS_SetResetCallback(ResetCB);
+	PAD_Init();
+	OGC_InitVideoSystem();
+	fatInitDefault();
+	/* Call the user's main function */
+	return(SDL_main(argc, argv));
+}
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
new file mode 100644
index 000000000..7cfc72400
--- /dev/null
+++ b/src/main/wii/SDL_wii_main.c
@@ -0,0 +1,76 @@
+/* Include the SDL main definition header */
+#include "SDL_main.h"
+#undef main
+
+/* Standard includes */
+#include <stdio.h>
+
+/* SDL includes */
+#include "../../video/ogc/SDL_ogc_video.h"
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+#include <wiiuse/wpad.h>
+#include <ogc/usbmouse.h>
+#include <wiikeyboard/keyboard.h>
+
+bool TerminateRequested=false, ShutdownRequested=false, ResetRequested=false;
+
+void SDL_Quit();
+static void ShutdownCB()
+{
+	TerminateRequested = 1;
+	ShutdownRequested = 1;
+}
+static void ResetCB()
+{
+	TerminateRequested = 1;
+	ResetRequested = 1;
+}
+void ShutdownWii()
+{
+	TerminateRequested = 0;
+	SDL_Quit();
+	SYS_ResetSystem(SYS_POWEROFF, 0, 0);
+}
+void RestartHomebrewChannel()
+{
+	TerminateRequested = 0;
+	SDL_Quit();
+	exit(1);
+}
+void Terminate()
+{
+	if (ShutdownRequested) ShutdownWii();
+	else if (ResetRequested) RestartHomebrewChannel();
+}
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+	L2Enhance();
+	u32 version = IOS_GetVersion();
+	s32 preferred = IOS_GetPreferredVersion();
+
+	if(preferred > 0 && version != (u32)preferred)
+		IOS_ReloadIOS(preferred);
+
+	// Wii Power/Reset buttons
+	WPAD_Init();
+	WPAD_SetPowerButtonCallback((WPADShutdownCallback)ShutdownCB);
+	SYS_SetPowerCallback(ShutdownCB);
+	SYS_SetResetCallback(ResetCB);
+	PAD_Init();
+	OGC_InitVideoSystem();
+	WPAD_SetDataFormat(WPAD_CHAN_ALL,WPAD_FMT_BTNS_ACC_IR);
+	WPAD_SetVRes(WPAD_CHAN_ALL, 640, 480);
+
+	MOUSE_Init();
+	KEYBOARD_Init(NULL);
+	fatInitDefault();
+	/* Call the user's main function */
+	return(SDL_main(argc, argv));
+}
+
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 8af6e52f4..e2c21bd6f 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -43,6 +43,8 @@
 #include "win32/SDL_systhread_c.h"
 #elif SDL_THREAD_SYMBIAN
 #include "symbian/SDL_systhread_c.h"
+#elif SDL_THREAD_OGC
+#include "ogc/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/ogc/SDL_syscond.c b/src/thread/ogc/SDL_syscond.c
new file mode 100644
index 000000000..27b403da2
--- /dev/null
+++ b/src/thread/ogc/SDL_syscond.c
@@ -0,0 +1,139 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+#include "SDL_sysmutex_c.h"
+
+#include <ogcsys.h>
+#include <ogc/cond.h>
+
+struct SDL_cond
+{
+	cond_t cond;
+};
+
+/* Create a condition variable */
+SDL_cond * SDL_CreateCond(void)
+{
+	SDL_cond *cond;
+
+	cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+	if (cond)
+	{
+		if (LWP_CondInit(&(cond->cond)) < 0)
+		{
+			SDL_DestroyCond(cond);
+			cond = NULL;
+		}
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+	return (cond);
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+	if (cond)
+	{
+		LWP_CondDestroy(cond->cond);
+		SDL_free(cond);
+	}
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	return LWP_CondSignal(cond->cond) == 0 ? 0 : -1;
+
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	return LWP_CondBroadcast(cond->cond) == 0 ? 0 : -1;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+ The mutex must be locked before entering this function!
+ The mutex is unlocked during the wait, and locked again after the wait.
+
+ Typical use:
+
+ Thread A:
+ SDL_LockMutex(lock);
+ while ( ! condition ) {
+ SDL_CondWait(cond);
+ }
+ SDL_UnlockMutex(lock);
+
+ Thread B:
+ SDL_LockMutex(lock);
+ ...
+ condition = true;
+ ...
+ SDL_UnlockMutex(lock);
+ */
+
+
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+	struct timespec time; 
+
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+	//LWP_CondTimedWait expects relative timeout
+	time.tv_sec = (ms / 1000);
+	time.tv_nsec = (ms % 1000) * 1000000;
+
+	return LWP_CondTimedWait(cond->cond, mutex->id, &time);
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+	return LWP_CondWait(cond->cond, mutex->id);
+}
diff --git a/src/thread/ogc/SDL_sysmutex.c b/src/thread/ogc/SDL_sysmutex.c
new file mode 100644
index 000000000..f6e498286
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex.c
@@ -0,0 +1,87 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <ogcsys.h>
+
+struct SDL_mutex
+{
+	u32 id;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+	SDL_mutex *mutex = NULL;
+
+	/* Allocate mutex memory */
+	mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+	if (mutex)
+	{
+		LWP_MutexInit(&mutex->id, 0);
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+	return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+	if (mutex)
+	{
+		LWP_MutexDestroy(mutex->id);
+		SDL_free(mutex);
+	}
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+	if (mutex == NULL)
+	{
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	return LWP_MutexLock(mutex->id);
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+	if (mutex == NULL)
+	{
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	return LWP_MutexUnlock(mutex->id);
+
+}
diff --git a/src/thread/ogc/SDL_sysmutex_c.h b/src/thread/ogc/SDL_sysmutex_c.h
new file mode 100644
index 000000000..9b37f359f
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+struct SDL_mutex {
+	Uint32 id;
+};
diff --git a/src/thread/ogc/SDL_syssem.c b/src/thread/ogc/SDL_syssem.c
new file mode 100644
index 000000000..3a9e38407
--- /dev/null
+++ b/src/thread/ogc/SDL_syssem.c
@@ -0,0 +1,175 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDL_semaphore
+{
+	Uint32 count;
+	Uint32 waiters_count;
+	SDL_mutex *count_lock;
+	SDL_cond *count_nonzero;
+};
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+	SDL_sem *sem;
+
+	sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+	if (!sem)
+	{
+		SDL_OutOfMemory();
+		return NULL;
+	}
+	sem->count = initial_value;
+	sem->waiters_count = 0;
+
+	sem->count_lock = SDL_CreateMutex();
+	sem->count_nonzero = SDL_CreateCond();
+	if (!sem->count_lock || !sem->count_nonzero)
+	{
+		SDL_DestroySemaphore(sem);
+		return NULL;
+	}
+
+	return sem;
+}
+
+/* WARNING:
+ You cannot call this function when another thread is using the semaphore.
+ */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+	if (sem)
+	{
+		sem->count = 0xFFFFFFFF;
+		while (sem->waiters_count > 0)
+		{
+			SDL_CondSignal(sem->count_nonzero);
+			SDL_Delay(10);
+		}
+		SDL_DestroyCond(sem->count_nonzero);
+		if (sem->count_lock)
+		{
+			SDL_mutexP(sem->count_lock);
+			SDL_mutexV(sem->count_lock);
+			SDL_DestroyMutex(sem->count_lock);
+		}
+		SDL_free(sem);
+	}
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+	int retval;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	retval = SDL_MUTEX_TIMEDOUT;
+	SDL_LockMutex(sem->count_lock);
+	if (sem->count > 0)
+	{
+		--sem->count;
+		retval = 0;
+	}
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+	int retval;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	/* A timeout of 0 is an easy case */
+	if (timeout == 0)
+	{
+		return SDL_SemTryWait(sem);
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	++sem->waiters_count;
+	retval = 0;
+	while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT))
+	{
+		retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock,
+				timeout);
+	}
+	--sem->waiters_count;
+	--sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+	return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+	Uint32 value;
+
+	value = 0;
+	if (sem)
+	{
+		SDL_LockMutex(sem->count_lock);
+		value = sem->count;
+		SDL_UnlockMutex(sem->count_lock);
+	}
+	return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	if (sem->waiters_count > 0)
+	{
+		SDL_CondSignal(sem->count_nonzero);
+	}
+	++sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return 0;
+}
diff --git a/src/thread/ogc/SDL_systhread.c b/src/thread/ogc/SDL_systhread.c
new file mode 100644
index 000000000..e720e91ac
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread.c
@@ -0,0 +1,80 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Thread management routines for SDL */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+
+#include <ogcsys.h>
+
+/*
+struct SDL_Thread {
+	Uint32 threadid;
+	SYS_ThreadHandle handle;
+	int status;
+	SDL_error errbuf;
+	void *data;
+};
+
+ */
+
+void *run_thread(void *data)
+{
+	SDL_RunThread(data);
+	return ((void *) 0); /* Prevent compiler warning */
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+	
+	if ( LWP_CreateThread(&thread->handle, run_thread, args, 0, 0, 64) != 0 ) {
+		SDL_SetError("Not enough resources to create thread");
+		return(-1);
+	}
+	
+	return (0);
+}
+
+void SDL_SYS_SetupThread(void)
+{
+	return;
+}
+
+Uint32 SDL_ThreadID(void)
+{
+	return (Uint32) LWP_GetSelf();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+	void *v;
+	LWP_JoinThread(thread->handle, &v);
+	return;
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+	return;
+}
diff --git a/src/thread/ogc/SDL_systhread_c.h b/src/thread/ogc/SDL_systhread_c.h
new file mode 100644
index 000000000..313544ca5
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Stub until we implement threads on this platform */
+
+typedef Uint32 SYS_ThreadHandle;
diff --git a/src/timer/ogc/SDL_systimer.c b/src/timer/ogc/SDL_systimer.c
new file mode 100644
index 000000000..931b8e8e9
--- /dev/null
+++ b/src/timer/ogc/SDL_systimer.c
@@ -0,0 +1,105 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_TIMER_OGC
+
+#include <ogc/lwp_watchdog.h>
+#include <ogc/video.h>
+
+#include "SDL_timer.h"
+#include "../SDL_timer_c.h"
+
+#include <ogcsys.h>
+
+static Uint64 start;
+
+void SDL_StartTicks(void)
+{
+	start = gettime();
+}
+
+Uint32 SDL_GetTicks (void)
+{
+	const Uint64 ticks	= gettime() - start;
+	const Uint64 ms		= ticks / TB_TIMER_CLOCK;
+	return ms;
+}
+
+void SDL_Delay (Uint32 ms)
+{
+	struct timespec elapsed, tv;
+	elapsed.tv_sec = ms/1000;
+	elapsed.tv_nsec = (ms%1000)*1000000;
+	tv.tv_sec = elapsed.tv_sec;
+	tv.tv_nsec = elapsed.tv_nsec;
+	nanosleep(&tv, &elapsed);
+}
+
+#include "SDL_thread.h"
+
+/* Data to handle a single periodic alarm */
+static int timer_alive = 0;
+static SDL_Thread *timer = NULL;
+
+static int RunTimer(void *unused)
+{
+	while ( timer_alive ) {
+		if ( SDL_timer_running ) {
+			SDL_ThreadedTimerCheck();
+		}
+		SDL_Delay(1);
+	}
+	return(0);
+}
+
+/* This is only called if the event thread is not running */
+int SDL_SYS_TimerInit(void)
+{
+	timer_alive = 1;
+	timer = SDL_CreateThread(RunTimer, NULL);
+	if ( timer == NULL )
+		return(-1);
+	return(SDL_SetTimerThreaded(1));
+}
+
+void SDL_SYS_TimerQuit(void)
+{
+	timer_alive = 0;
+	if ( timer ) {
+		SDL_WaitThread(timer, NULL);
+		timer = NULL;
+	}
+}
+
+int SDL_SYS_StartTimer(void)
+{
+	SDL_SetError("Internal logic error: threaded timer in use");
+	return(-1);
+}
+
+void SDL_SYS_StopTimer(void)
+{
+	return;
+}
+
+#endif
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 436450e33..65d56a56b 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -410,6 +410,9 @@ extern VideoBootStrap AALIB_bootstrap;
 #if SDL_VIDEO_DRIVER_CACA
 extern VideoBootStrap CACA_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_OGC
+extern VideoBootStrap OGC_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
 #endif
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 46285c990..bf379f4b6 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -126,6 +126,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_CACA
 	&CACA_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_OGC
+	&OGC_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
 #endif
diff --git a/src/video/gamecube/SDL_gamecube_events.c b/src/video/gamecube/SDL_gamecube_events.c
new file mode 100644
index 000000000..e44a84a9e
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_events.c
@@ -0,0 +1,13 @@
+#include "SDL_config.h"
+
+
+#include "SDL.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+
+#include "../ogc/SDL_ogc_video.h"
+#include "SDL_gamecube_events_c.h"
+
+void GAMECUBE_PumpEvents(_THIS) {}
+
+void GAMECUBE_InitOSKeymap(_THIS) {}
diff --git a/src/video/gamecube/SDL_gamecube_events_c.h b/src/video/gamecube/SDL_gamecube_events_c.h
new file mode 100644
index 000000000..5084d26f5
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_events_c.h
@@ -0,0 +1,4 @@
+#include "SDL_config.h"
+
+extern void GAMECUBE_InitOSKeymap(_THIS);
+extern void GAMECUBE_PumpEvents(_THIS);
diff --git a/src/video/gamecube/SDL_gamecube_mouse.c b/src/video/gamecube/SDL_gamecube_mouse.c
new file mode 100644
index 000000000..9511d820b
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_mouse.c
@@ -0,0 +1,8 @@
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/ogc/SDL_ogc_video.c b/src/video/ogc/SDL_ogc_video.c
new file mode 100644
index 000000000..e5b968463
--- /dev/null
+++ b/src/video/ogc/SDL_ogc_video.c
@@ -0,0 +1,873 @@
+/*
+	SDL - Simple DirectMedia Layer
+	Copyright (C) 1997-2006 Sam Lantinga
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Lesser General Public
+	License as published by the Free Software Foundation; either
+	version 2.1 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+	Tantric, 2009
+*/
+#include "SDL_config.h"
+
+// Standard includes.
+#include <math.h>
+
+// SDL internal includes.
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+
+// SDL ogc specifics.
+#include <gccore.h>
+#include <ogcsys.h>
+#include <malloc.h>
+#include <wiiuse/wpad.h>
+#include "SDL_ogc_video.h"
+
+#ifdef __wii__
+#include "../wii/SDL_wiievents_c.h"
+#endif
+
+#ifdef __gamecube__
+#include "../gamecube/SDL_gamecube_events_c.h"
+#endif
+
+
+#include <ogc/machine/processor.h>
+
+static const char	OGCVID_DRIVER_NAME[] = "ogc-video";
+static lwp_t videothread = LWP_THREAD_NULL;
+static SDL_mutex *videomutex = NULL;
+static SDL_cond *videocond = NULL;
+static ogcVideo *current = NULL;
+
+int vresx=0, vresy=0;
+
+/*** SDL ***/
+static SDL_Rect mode_320, mode_640;
+#ifdef __wii__
+static SDL_Rect mode_848;
+#endif
+
+static SDL_Rect* modes_descending[] =
+{
+#ifdef __wii__
+	&mode_848,
+#endif
+	&mode_640,
+	&mode_320,
+	NULL
+};
+
+
+/*** 2D Video ***/
+#define HASPECT 			320
+#define VASPECT 			240
+
+unsigned char *xfb = NULL;
+GXRModeObj* vmode = 0;
+static int quit_flip_thread = 0;
+static GXTexObj texobj_a, texobj_b;
+static GXTlutObj texpalette_a, texpalette_b;
+
+/*** GX ***/
+#define DEFAULT_FIFO_SIZE 256 * 1024
+static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
+
+/* New texture based scaler */
+typedef struct tagcamera
+{
+	guVector pos;
+	guVector up;
+	guVector view;
+}
+camera;
+
+/*** Square Matrix
+     This structure controls the size of the image on the screen.
+	 Think of the output as a -80 x 80 by -60 x 60 graph.
+***/
+static s16 square[] ATTRIBUTE_ALIGN (32) =
+{
+  /*
+   * X,   Y,  Z
+   * Values set are for roughly 4:3 aspect
+   */
+	-HASPECT,  VASPECT, 0,	// 0
+	 HASPECT,  VASPECT, 0,	// 1
+	 HASPECT, -VASPECT, 0,	// 2
+	-HASPECT, -VASPECT, 0	// 3
+};
+
+static const f32 tex_pos[] ATTRIBUTE_ALIGN(32) = {
+	0.0, 0.0,
+	1.0, 0.0,
+	1.0, 1.0,
+	0.0, 1.0,
+};
+
+static camera cam = {
+	{0.0F, 0.0F, 0.0F},
+	{0.0F, 0.5F, 0.0F},
+	{0.0F, 0.0F, -0.5F}
+};
+
+/****************************************************************************
+ * Scaler Support Functions
+ ***************************************************************************/
+static int currentwidth;
+static int currentheight;
+static int currentbpp;
+
+static void
+draw_init(void *palette, void *tex)
+{
+	Mtx m, mv, view;
+
+	GX_ClearVtxDesc ();
+	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
+	GX_SetVtxDesc (GX_VA_TEX0, GX_INDEX8);
+
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+
+	GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
+	GX_SetArray (GX_VA_TEX0, (void*)tex_pos, 2 * sizeof (f32));
+	GX_SetNumTexGens (1);
+	GX_SetNumChans (0);
+
+	GX_SetTexCoordGen (GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+	GX_SetTevOp (GX_TEVSTAGE0, GX_REPLACE);
+	GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
+
+	memset(&view, 0, sizeof (Mtx));
+	guLookAt(view, &cam.pos, &cam.up, &cam.view);
+	guMtxIdentity(m);
+	guMtxTransApply(m, m, 0, 0, -100);
+	guMtxConcat(view, m, mv);
+	GX_LoadPosMtxImm(mv, GX_PNMTX0);
+
+	GX_InvVtxCache ();	// update vertex cache
+
+	if (currentbpp == 8) {
+		GX_InitTlutObj(&texpalette_a, palette, GX_TL_IA8, 256);
+		GX_InitTlutObj(&texpalette_b, (Uint16*)palette+256, GX_TL_IA8, 256);
+		DCStoreRange(palette, sizeof(512*sizeof(Uint16)));
+		GX_LoadTlut(&texpalette_a, GX_TLUT0);
+		GX_LoadTlut(&texpalette_b, GX_TLUT1);
+
+		GX_InitTexObjCI(&texobj_a, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
+		GX_InitTexObjCI(&texobj_b, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
+		GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+		// Setup TEV to combine Red+Green and Blue paletted images
+		GX_SetTevColor(GX_TEVREG0, (GXColor){255, 255, 0, 0});
+		GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		// first stage = red and green
+		GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
+		GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
+		// second stage = add blue (and opaque alpha)
+		GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
+		GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
+		GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
+		GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
+		GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
+
+		GX_SetNumTevStages(2);
+	}
+	else if (currentbpp == 16)
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
+	else
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
+
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);	// load texture object so its ready to use
+}
+
+static inline void
+draw_vert (u8 index)
+{
+	GX_Position1x8 (index);
+	GX_TexCoord1x8 (index);
+}
+
+static inline void
+draw_square ()
+{
+	GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+	draw_vert(0);
+	draw_vert(1);
+	draw_vert(2);
+	draw_vert(3);
+	GX_End();
+}
+
+static void * flip_thread (void *arg)
+{
+	u32 *tex = (u32*)arg;
+
+	GX_SetCurrentGXThread();
+
+	// clear EFB
+	GX_CopyDisp(xfb, GX_TRUE);
+
+	SDL_mutexP(videomutex);
+
+	while(!quit_flip_thread)
+	{
+		// update texture
+		DCStoreRange((void*)tex[0], tex[1]);
+		// clear texture objects
+		GX_InvalidateTexAll();
+		draw_square(); // render textured quad
+
+		VIDEO_WaitVSync();
+		GX_CopyDisp(xfb, GX_FALSE);
+
+		GX_DrawDone();
+
+		SDL_CondWait(videocond, videomutex);
+	}
+	SDL_mutexV(videomutex);
+
+	return NULL;
+}
+
+static void
+SetupGX()
+{
+	Mtx44 p;
+	int df = 1; // deflicker on/off
+
+	GX_SetCurrentGXThread();
+	GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
+	GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
+	GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
+
+	GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+	GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
+	GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, (df == 1) ? GX_TRUE : GX_FALSE, vmode->vfilter);
+
+	GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
+	GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
+	GX_SetDispCopyGamma (GX_GM_1_0);
+	GX_SetCullMode (GX_CULL_NONE);
+	GX_SetBlendMode(GX_BM_NONE,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
+
+	GX_SetZMode (GX_FALSE, GX_LEQUAL, GX_TRUE);
+	GX_SetColorUpdate (GX_TRUE);
+	GX_SetAlphaUpdate(GX_FALSE);
+
+	guOrtho(p, VASPECT, -VASPECT, -HASPECT, HASPECT, 100, 1000); // matrix, t, b, l, r, n, f
+	GX_LoadProjectionMtx (p, GX_ORTHOGRAPHIC);
+	GX_Flush();
+}
+
+static void
+StartVideoThread(void *args)
+{
+	if(videothread == LWP_THREAD_NULL)
+	{
+		quit_flip_thread = 0;
+		LWP_CreateThread(&videothread, flip_thread, args, NULL, 0, 68);
+	}
+}
+
+void OGC_VideoStart(ogcVideo *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
+	}
+
+	SetupGX();
+	draw_init(private->palette, private->texturemem);
+	StartVideoThread(&private->texturemem);
+#ifdef __wii__
+	WPAD_SetVRes(WPAD_CHAN_0, vresx+vresx/4, vresy+vresy/4);
+#endif
+	current = private;
+}
+
+void OGC_VideoStop()
+{
+	if(videothread == LWP_THREAD_NULL)
+		return;
+
+	SDL_LockMutex(videomutex);
+	quit_flip_thread = 1;
+	SDL_CondSignal(videocond);
+	SDL_UnlockMutex(videomutex);
+
+	LWP_JoinThread(videothread, NULL);
+	videothread = LWP_THREAD_NULL;
+}
+
+static int OGC_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	// Set up the modes.
+#ifdef __wii__
+	mode_848.w = 848;
+	mode_848.h = 480;
+#endif
+	mode_640.w = 640;
+	mode_640.h = 480;
+	mode_320.w = 320;
+	mode_320.h = 240;
+
+	// Set the current format.
+	vformat->BitsPerPixel	= 16;
+	vformat->BytesPerPixel	= 2;
+
+	this->hidden->buffer = NULL;
+	this->hidden->texturemem = NULL;
+	this->hidden->width = 0;
+	this->hidden->height = 0;
+	this->hidden->pitch = 0;
+
+	/* We're done! */
+	return 0;
+}
+
+static SDL_Rect **OGC_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+	return modes_descending;
+}
+
+static SDL_Surface *OGC_SetVideoMode(_THIS, SDL_Surface *current,
+								   int width, int height, int bpp, Uint32 flags)
+{
+	SDL_Rect* 		mode;
+	size_t			bytes_per_pixel;
+	Uint32			r_mask = 0;
+	Uint32			b_mask = 0;
+	Uint32			g_mask = 0;
+
+	// Find a mode big enough to store the requested resolution
+	mode = modes_descending[0];
+	while (mode)
+	{
+		if (mode->w == width && mode->h == height)
+			break;
+		else
+			++mode;
+	}
+
+	// Didn't find a mode?
+	if (!mode)
+	{
+		SDL_SetError("Display mode (%dx%d) is unsupported.",
+			width, height);
+		return NULL;
+	}
+
+	if(bpp != 8 && bpp != 16 && bpp != 24 && bpp != 32)
+	{
+		SDL_SetError("Resolution (%d bpp) is unsupported (8/16/24/32 bpp only).",
+			bpp);
+		return NULL;
+	}
+
+	bytes_per_pixel = bpp / 8;
+
+	OGC_VideoStop();
+
+	free(this->hidden->buffer);
+	free(this->hidden->texturemem);
+
+	// Allocate the new buffer.
+	this->hidden->buffer = memalign(32, width * height * bytes_per_pixel);
+	if (!this->hidden->buffer )
+	{
+		this->hidden->texturemem = NULL;
+		SDL_SetError("Couldn't allocate buffer for requested mode");
+		return(NULL);
+	}
+
+	// Allocate texture memory
+	if (bytes_per_pixel > 2)
+		this->hidden->texturemem_size = width * height * 4;
+	else
+		this->hidden->texturemem_size = width * height * bytes_per_pixel;
+
+	this->hidden->texturemem = memalign(32, this->hidden->texturemem_size);
+	if (this->hidden->texturemem == NULL)
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		SDL_SetError("Couldn't allocate memory for texture");
+		return NULL;
+	}
+
+	// Allocate the new pixel format for the screen
+	if (!SDL_ReallocFormat(current, bpp, r_mask, g_mask, b_mask, 0))
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		free(this->hidden->texturemem);
+		this->hidden->texturemem = NULL;
+
+		SDL_UnlockMutex(videomutex);
+		SDL_SetError("Couldn't allocate new pixel format for requested mode");
+		return NULL;
+	}
+
+	// Clear the buffer
+	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
+	SDL_memset(this->hidden->texturemem, 0, this->hidden->texturemem_size);
+
+	// Set up the new mode framebuffer
+	current->flags = flags & (SDL_FULLSCREEN | SDL_HWPALETTE | SDL_NOFRAME);
+	// Our surface is always double buffered
+	current->flags |= SDL_PREALLOC | SDL_DOUBLEBUF;
+	current->w = width;
+	current->h = height;
+	current->pitch = current->w * bytes_per_pixel;
+	current->pixels = this->hidden->buffer;
+
+	/* Set the hidden data */
+	this->hidden->width = current->w;
+	this->hidden->height = current->h;
+	this->hidden->pitch = current->w * (bytes_per_pixel > 2 ? 4 : bytes_per_pixel);
+
+	currentwidth = current->w;
+	currentheight = current->h;
+	currentbpp = bpp;
+	vresx = currentwidth;
+	vresy = currentheight;
+
+	OGC_VideoStart(this->hidden);
+
+	return current;
+}
+
+/* We don't actually allow hardware surfaces other than the main one */
+static int OGC_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(-1);
+}
+
+static void OGC_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static int OGC_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(0);
+}
+
+static void OGC_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static inline void Set_RGBAPixel(_THIS, int x, int y, u32 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color;
+	*(truc + offset + 1) = color >> 24;
+	*(truc + offset + 32) = color >> 16;
+	*(truc + offset + 33) = color >> 8;
+}
+
+static inline void Set_RGB565Pixel(_THIS, int x, int y, u16 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color >> 8;
+	*(truc + offset + 1) = color;
+}
+
+static inline void Set_PalPixel(_THIS, int x, int y, u8 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->pitch;
+	u32 offset;
+
+	offset = ((y & ~3) * width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+	truc[offset] = color;
+}
+
+static void UpdateRect_8(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 color;
+	int i, j;
+
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + rect->x);
+		for (j = 0; j < rect->w; j++)
+		{
+			color = src[j];
+			Set_PalPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_16(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u16 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 2 * (i + rect->y)) + (rect->x * 2));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 2);
+			color = (ptr[0] << 8) | ptr[1];
+			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_24(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 3 * (i + rect->y)) + (rect->x * 3));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 3);
+			color = (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | 0xff;
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_32(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 4 * (i + rect->y)) + (rect->x * 4));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 4);
+			color = (ptr[1] << 24) | (ptr[2] << 16) | (ptr[3] << 8) | ptr[0];
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void flipHWSurface_16_16(_THIS, const SDL_Surface* const surface)
+{
+	int h, w;
+	long long int *dst = (long long int *) this->hidden->texturemem;
+	long long int *src1 = (long long int *) this->hidden->buffer;
+	long long int *src2 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 1));
+	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
+	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
+	int rowpitch = (this->hidden->pitch >> 3) * 3;
+
+	SDL_mutexP(videomutex);
+	for (h = 0; h < this->hidden->height; h += 4)
+	{
+		for (w = 0; w < this->hidden->pitch; w += 8)
+		{
+			*dst++ = *src1++;
+			*dst++ = *src2++;
+			*dst++ = *src3++;
+			*dst++ = *src4++;
+		}
+
+		src1 = src4;
+		src2 += rowpitch;
+		src3 += rowpitch;
+		src4 += rowpitch;
+	}
+	SDL_CondSignal(videocond);
+	SDL_mutexV(videomutex);
+}
+
+static void OGC_UpdateRect(_THIS, SDL_Rect *rect)
+{
+	const SDL_Surface* const screen = this->screen;
+
+	switch(screen->format->BytesPerPixel) {
+	case 1:
+		UpdateRect_8(this, rect);
+		break;
+	case 2:
+		UpdateRect_16(this, rect);
+		break;
+	case 3:
+		UpdateRect_24(this, rect);
+		break;
+	case 4:
+		UpdateRect_32(this, rect);
+		break;
+	default:
+		fprintf(stderr, "Invalid BPP %d\n", screen->format->BytesPerPixel);
+		break;
+	}
+}
+
+static void OGC_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+{
+	int i;
+
+	// note that this function doesn't lock - we don't care if this isn't
+	// rendered now, that's what Flip is for
+
+	for (i = 0; i < numrects; i++)
+	{
+		OGC_UpdateRect(this, rects+i);
+	}
+
+	SDL_CondSignal(videocond);
+}
+
+static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	OGC_UpdateRects(this, 1, &screen_rect);
+}
+
+static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	OGC_UpdateRects(this, 1, &screen_rect);
+}
+
+static int OGC_FlipHWSurface(_THIS, SDL_Surface *surface)
+{
+	switch(surface->format->BytesPerPixel)
+	{
+		case 1:
+		case 2:
+			// 8 and 16 bit use the same tile format
+			flipHWSurface_16_16(this, surface);
+			break;
+		case 3:
+			flipHWSurface_24_16(this, surface);
+			break;
+		case 4:
+			flipHWSurface_32_16(this, surface);
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static int OGC_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
+{
+	const int last_color = first_color + color_count;
+	Uint16* const palette = this->hidden->palette;
+	int     component;
+
+	SDL_LockMutex(videomutex);
+
+	/* Build the RGB24 palette. */
+	for (component = first_color; component != last_color; ++component, ++colors)
+	{
+		palette[component] = (colors->g << 8) | colors->r;
+		palette[component+256] = colors->b;
+	}
+
+	DCStoreRangeNoSync(palette+first_color, color_count*sizeof(Uint16));
+	DCStoreRange(palette+first_color+256, color_count*sizeof(Uint16));
+	GX_LoadTlut(&texpalette_a, GX_TLUT0);
+	GX_LoadTlut(&texpalette_b, GX_TLUT1);
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);
+	GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+	SDL_UnlockMutex(videomutex);
+
+	return(1);
+}
+
+static void OGC_VideoQuit(_THIS)
+{
+	OGC_VideoStop();
+	GX_AbortFrame();
+	GX_Flush();
+
+	current = NULL;
+
+	VIDEO_SetBlack(TRUE);
+	VIDEO_Flush();
+
+	free(this->hidden->buffer);
+	this->hidden->buffer = NULL;
+	free(this->hidden->texturemem);
+	this->hidden->texturemem = NULL;
+}
+
+static void OGC_DeleteDevice(SDL_VideoDevice *device)
+{
+	free(device->hidden);
+	SDL_free(device);
+
+	SDL_DestroyCond(videocond);
+	videocond = 0;
+	SDL_DestroyMutex(videomutex);
+	videomutex=0;
+}
+
+static SDL_VideoDevice *OGC_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( device ) {
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)
+			memalign(32, sizeof(struct SDL_PrivateVideoData));
+	}
+	if ( (device == NULL) || (device->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( device ) {
+			SDL_free(device);
+		}
+		return(0);
+	}
+	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+	videomutex = SDL_CreateMutex();
+	videocond = SDL_CreateCond();
+
+	/* Set the function pointers */
+	device->VideoInit = OGC_VideoInit;
+	device->ListModes = OGC_ListModes;
+	device->SetVideoMode = OGC_SetVideoMode;
+	device->SetColors = OGC_SetColors;
+	device->UpdateRects = OGC_UpdateRects;
+	device->VideoQuit = OGC_VideoQuit;
+	device->AllocHWSurface = OGC_AllocHWSurface;
+	device->LockHWSurface = OGC_LockHWSurface;
+	device->UnlockHWSurface = OGC_UnlockHWSurface;
+	device->FlipHWSurface = OGC_FlipHWSurface;
+	device->FreeHWSurface = OGC_FreeHWSurface;
+#ifdef __wii__
+	device->InitOSKeymap = WII_InitOSKeymap;
+	device->PumpEvents = WII_PumpEvents;
+#endif
+#ifdef __gamecube__
+	device->InitOSKeymap = GAMECUBE_InitOSKeymap;
+	device->PumpEvents = GAMECUBE_PumpEvents;
+#endif
+	device->input_grab = SDL_GRAB_ON;
+
+	device->free = OGC_DeleteDevice;
+
+	OGC_InitVideoSystem();
+	return device;
+}
+
+static int OGC_Available(void)
+{
+	return(1);
+}
+
+VideoBootStrap OGC_bootstrap = {
+	OGCVID_DRIVER_NAME, "ogc video driver",
+	OGC_Available, OGC_CreateDevice
+};
+
+void
+OGC_InitVideoSystem()
+{
+	/* Initialise the video system */
+	VIDEO_Init();
+	vmode = VIDEO_GetPreferredMode(NULL);
+
+	/* Set up the video system with the chosen mode */
+	if (vmode == &TVPal528IntDf)
+		vmode = &TVPal576IntDfScale;
+
+	VIDEO_Configure(vmode);
+
+	// Allocate the video buffer
+	if (xfb) free(MEM_K1_TO_K0(xfb));
+	xfb = (unsigned char*) MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+
+	VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
+	VIDEO_SetNextFramebuffer(xfb);
+
+	// Show the screen.
+	VIDEO_SetBlack(FALSE);
+	VIDEO_Flush();
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
+
+	//CON_Init(xfb,20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
+
+	/*** Clear out FIFO area ***/
+	memset(&gp_fifo, 0, DEFAULT_FIFO_SIZE);
+
+	/*** Initialise GX ***/
+	GX_Init(&gp_fifo, DEFAULT_FIFO_SIZE);
+
+	GXColor background = { 0, 0, 0, 0xff };
+	GX_SetCopyClear (background, GX_MAX_Z24);
+
+	SetupGX();
+}
+
+void OGC_SetWidescreen(int wide)
+{
+	int width;
+	if(wide) {
+		width = 678;
+	}
+	else
+		width = 640;
+
+	vmode->viWidth = width;
+	vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - width) / 2;
+
+	VIDEO_Configure (vmode);
+
+	if (xfb)
+		VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
+
+	VIDEO_Flush();
+
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
+}
+
+void OGC_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
+{
+	square[6] = square[3]  =  xscale + xshift;
+	square[0] = square[9]  = -xscale + xshift;
+	square[4] = square[1]  =  yscale - yshift;
+	square[7] = square[10] = -yscale - yshift;
+	DCFlushRange (square, 32); // update memory BEFORE the GPU accesses it!
+	GX_InvVtxCache();
+}
diff --git a/src/video/ogc/SDL_ogc_video.h b/src/video/ogc/SDL_ogc_video.h
new file mode 100644
index 000000000..f104034d6
--- /dev/null
+++ b/src/video/ogc/SDL_ogc_video.h
@@ -0,0 +1,37 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_ogc_video_h
+#define _SDL_ogc_video_h
+
+/* SDL internal includes */
+#include "../SDL_sysvideo.h"
+
+/* OGC includes */
+#include <ogc/gx_struct.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_VideoDevice *this
+
+/* Private display data */
+typedef struct SDL_PrivateVideoData
+{
+    // 2x256x16bit palettes = 1x256x24(32)bit palette
+    // first 256 entries are for Red/Green
+    // last 256 entries are for Green
+    Uint16 palette[2*256];
+
+    Uint8* buffer;
+
+    // these two fields MUST be in this order
+    Uint8* texturemem;
+    size_t texturemem_size;
+
+    int    width;
+    int    height;
+    int    pitch;
+} ogcVideo;
+
+void OGC_InitVideoSystem();
+void OGC_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
+
+#endif /* _SDL_wiivideo_h */
diff --git a/src/video/wii/SDL_wiievents.c b/src/video/wii/SDL_wiievents.c
new file mode 100644
index 000000000..9a75458f6
--- /dev/null
+++ b/src/video/wii/SDL_wiievents.c
@@ -0,0 +1,242 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+    Yohanes Nugroho (yohanes@gmail.com)
+	Tantric
+*/
+#include "SDL_config.h"
+
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+#include <wiiuse/wpad.h>
+#include <malloc.h>
+#include <unistd.h>
+#include <ogc/usbmouse.h>
+#include <wiikeyboard/keyboard.h>
+#include <ogc/pad.h>
+
+#include "SDL_wiievents_c.h"
+
+static SDLKey keymap[232];
+
+static int posted;
+
+extern bool TerminateRequested;
+extern void Terminate();
+extern int vresx, vresy;
+
+void PumpEvents()
+{
+	s32 stat;
+#ifdef HW_RVL
+	keyboard_event ke;
+	mouse_event me;
+
+	if (TerminateRequested) Terminate();
+#endif
+
+	// this will only work if Joystick 0 has been opened and has been polled
+	WPADData *wd = WPAD_Data(WPAD_CHAN_0);
+	if (wd && wd->exp.type != WPAD_EXP_CLASSIC && wd->ir.valid) {
+		// use SDL_BUTTON_X2 to signal that this is the wiimote acting as a mouse
+		Uint8 Buttons = SDL_GetMouseState(NULL, NULL)|SDL_BUTTON_X2MASK;
+		if (wd->ir.x < vresx/8)
+			wd->ir.x = vresx/8;
+		else if (wd->ir.x > (vresx + vresx/8))
+			wd->ir.x = vresx + vresx/8;
+		if (wd->ir.y < vresy/8)
+			wd->ir.y = vresy/8;
+		else if (wd->ir.y > (vresy + vresy/8))
+			wd->ir.y = vresy + vresy/8;
+		posted += SDL_PrivateMouseMotion(Buttons, 0, wd->ir.x - vresx/8, wd->ir.y - vresy/8);
+		// most apps will ignore this (hopefully)
+		posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_X2, 0, 0);
+		wd->ir.valid = 0;
+	}
+
+	stat = KEYBOARD_GetEvent(&ke);
+	if (stat && (ke.type == KEYBOARD_RELEASED || ke.type == KEYBOARD_PRESSED))
+	{
+		SDL_keysym keysym;
+		memset(&keysym, 0, sizeof(keysym));
+		Uint8 keystate = (ke.type == KEYBOARD_PRESSED) ? SDL_PRESSED : SDL_RELEASED;
+		keysym.sym = keymap[ke.keycode];
+		keysym.unicode = ke.symbol;
+		keysym.mod = 0;
+		posted += SDL_PrivateKeyboard(keystate, &keysym);
+	}
+
+	stat = MOUSE_GetEvent(&me);
+	if (stat)
+	{
+		u8 button = me.button;
+		Uint8 mouse_state = SDL_GetMouseState(NULL, NULL);
+
+		posted += SDL_PrivateMouseMotion(0, 1, me.rx*2, me.ry*2);
+
+		if (button & 0x1) {
+			if (!(mouse_state & SDL_BUTTON_LMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_LEFT, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_LMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_LEFT, 0, 0);
+
+		if (button & 0x2) {
+			if (!(mouse_state & SDL_BUTTON_RMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_RIGHT, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_RMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_RIGHT, 0, 0);
+
+		if (button & 0x4) {
+			if (!(mouse_state & SDL_BUTTON_MMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_MIDDLE, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_MMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_MIDDLE, 0, 0);
+
+		// mouse wheel actions are single events (rz==1(up) or rz==-1(down))
+		// send SDL_PRESSED immediately followed by SDL_RELEASED
+		if (me.rz > 0) {
+			posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELUP, 0, 0);
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELUP, 0, 0);
+		}
+		else if (me.rz < 0) {
+			posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELDOWN, 0, 0);
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELDOWN, 0, 0);
+		}
+	}
+}
+
+void WII_PumpEvents(_THIS)
+{
+	do
+	{
+		posted = 0;
+		PumpEvents();
+		usleep(100);
+	} while (posted);
+}
+
+void WII_InitOSKeymap(_THIS)
+{
+	int i;
+
+	for (i = 0; i < 232; ++i)
+		keymap[i] = SDLK_UNKNOWN;
+
+	// a-z
+	for (i = 0; i < 27; i++)
+		keymap[4 + i] = SDLK_a + i;
+
+	// 1-9
+	for (i = 0; i < 9; i++)
+		keymap[30 + i] = SDLK_1 + i;
+
+	keymap[39] = SDLK_0;
+	keymap[40] = SDLK_RETURN;
+	keymap[41] = SDLK_ESCAPE;
+	keymap[42] = SDLK_BACKSPACE;
+	keymap[43] = SDLK_TAB;
+	keymap[44] = SDLK_SPACE;
+	keymap[45] = SDLK_MINUS;
+	keymap[46] = SDLK_EQUALS;
+	keymap[47] = SDLK_LEFTBRACKET;
+	keymap[48] = SDLK_RIGHTBRACKET;
+	keymap[49] = SDLK_BACKSLASH;
+	keymap[50] = SDLK_UNKNOWN; // unused
+	keymap[51] = SDLK_SEMICOLON;
+	keymap[52] = SDLK_QUOTE;
+	keymap[53] = SDLK_BACKQUOTE;
+	keymap[54] = SDLK_COMMA;
+	keymap[55] = SDLK_PERIOD;
+	keymap[56] = SDLK_SLASH;
+	keymap[57] = SDLK_CAPSLOCK;
+
+	// F1 to F12
+	for (i = 0; i < 12; i++)
+		keymap[58 + i] = SDLK_F1 + i;
+
+	keymap[70] = SDLK_PRINT;
+	keymap[71] = SDLK_SCROLLOCK;
+	keymap[72] = SDLK_PAUSE;
+	keymap[73] = SDLK_INSERT;
+	keymap[74] = SDLK_HOME;
+	keymap[75] = SDLK_PAGEUP;
+	keymap[76] = SDLK_DELETE;
+	keymap[77] = SDLK_END;
+	keymap[78] = SDLK_PAGEDOWN;
+
+	keymap[79] = SDLK_RIGHT;
+	keymap[80] = SDLK_LEFT;
+	keymap[81] = SDLK_DOWN;
+	keymap[82] = SDLK_UP;
+	keymap[83] = SDLK_NUMLOCK;
+
+	keymap[84] = SDLK_KP_DIVIDE;
+	keymap[85] = SDLK_KP_MULTIPLY;
+	keymap[86] = SDLK_KP_MINUS;
+	keymap[87] = SDLK_KP_PLUS;
+
+	keymap[88] = SDLK_KP_ENTER;
+
+	// keypad 1-9
+	for (i = 0; i < 9; i++)
+		keymap[89 + i] = SDLK_KP1 + i;
+
+	keymap[98] = SDLK_KP0;
+	keymap[99] = SDLK_KP_PERIOD;
+	keymap[100] = SDLK_UNKNOWN; // unused
+	keymap[101] = SDLK_UNKNOWN; // Applic
+	keymap[102] = SDLK_POWER;
+	keymap[103] = SDLK_KP_EQUALS;
+	keymap[104] = SDLK_F13;
+	keymap[105] = SDLK_F14;
+	keymap[106] = SDLK_F15;
+	keymap[107] = SDLK_UNKNOWN; // F16
+	keymap[108] = SDLK_UNKNOWN; // F17
+	keymap[109] = SDLK_UNKNOWN; // F18
+	keymap[110] = SDLK_UNKNOWN; // F19
+	keymap[111] = SDLK_UNKNOWN; // F20
+	keymap[112] = SDLK_UNKNOWN; // F21
+	keymap[113] = SDLK_UNKNOWN; // F22
+	keymap[114] = SDLK_UNKNOWN; // F23
+	keymap[115] = SDLK_UNKNOWN; // F24
+	keymap[116] = SDLK_UNKNOWN; // Execute
+	keymap[117] = SDLK_HELP;
+	keymap[118] = SDLK_MENU;
+	keymap[119] = SDLK_UNKNOWN; // Select
+	keymap[120] = SDLK_UNKNOWN; // Stop
+	keymap[121] = SDLK_UNKNOWN; // Again
+	keymap[122] = SDLK_UNDO;
+
+	keymap[134] = SDLK_KP_EQUALS;
+	// 135-143 - International
+	// 144-152 - Language
+	keymap[154] = SDLK_SYSREQ;
+
+	keymap[224] = SDLK_LCTRL;
+	keymap[225] = SDLK_LSHIFT;
+	keymap[226] = SDLK_LALT;
+	keymap[227] = SDLK_LMETA;
+	keymap[228] = SDLK_RCTRL;
+	keymap[229] = SDLK_RSHIFT;
+	keymap[230] = SDLK_RALT;
+	keymap[231] = SDLK_RMETA;
+}
diff --git a/src/video/wii/SDL_wiievents_c.h b/src/video/wii/SDL_wiievents_c.h
new file mode 100644
index 000000000..c75b13d1f
--- /dev/null
+++ b/src/video/wii/SDL_wiievents_c.h
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "../ogc/SDL_ogc_video.h"
+
+/* Variables and functions exported by SDL_sysevents.c to other parts 
+   of the native video subsystem (SDL_sysvideo.c)
+*/
+extern void WII_InitOSKeymap(_THIS);
+extern void WII_PumpEvents(_THIS);
+
+/* end of SDL_wiievents_c.h ... */
+
diff --git a/src/video/wii/SDL_wiimouse.c b/src/video/wii/SDL_wiimouse.c
new file mode 100644
index 000000000..fe380dda8
--- /dev/null
+++ b/src/video/wii/SDL_wiimouse.c
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_wiimouse_c.h"
+
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/wii/SDL_wiimouse_c.h b/src/video/wii/SDL_wiimouse_c.h
new file mode 100644
index 000000000..74ac4abc0
--- /dev/null
+++ b/src/video/wii/SDL_wiimouse_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "../ogc/SDL_ogc_video.h"
+
+/* Functions to be exported */
